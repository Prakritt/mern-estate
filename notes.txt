npm create vite@latest client  -- > Client is the folder inside which we want to initialize react. 
Package.json contains the dependencies. In order to install it, just hit nom install 
extensions : react snippets, Auto Rename Tag , console ninja(used for console logging inside vs code), Prettier, Tailwind Css Intellisense
All the pages of the application will be placed inside the "Pages" folder inside the "src" folder.

npm install react-router-dom
Inside App.jsx:
    import { BrowserRouter, Routes, Route } from 'react-router-dom'
    return <BrowserRouter>
        <Routes>
        <Route path = "/" element={<Home/>}/>
        <Route path ="/sign-in" element={<SignIn/>}/>
        <Route path = "/sign-up" element={<SignUp/>}/>
        <Route path = "/profile" element ={<Profile/>}/>
        <Route path = "/about" element ={<About/>}/>
        
        </Routes>
    </BrowserRouter>



For components, components are stored inside "components" folder inside "src" folder. 
Header component will be placed between BrowserRouter and Route as: 
    <BrowserRouter>
  <Header/>
    <Routes>


We can get icons from the package react-icons: npm install react-icons:
    import {FaSearch} from 'react-icons/fa'

To redirect on a click:
    import {Link} from 'react-router-dom'
    Link redirects us from one page to the another without refreshing the page. 

While connecting to the database: 
    mongoose.connect("mongodb+srv://Prakrit:mongodb123@mern-estate.lf0bqat.mongodb.net/mern-estate?retryWrites=true&w=majority")
    mern-estate after / and before ? denoted the name of the cluster in the database. 


Model : 
 Models contains the rules and requirements so that the person communicating with the database follows these
 rules and regulations and create data based on these rules. 
 const userSchema = new mongoose.Schema({name:{type:String,unique:true}},{timestamps:true}
 api>models>user.model.js
 Inside the schema, setting the {timestamps : true} does the following : 
    a. Time of creation of user 
    b. time of update of user
    later while sorting these info can be used to sort them by latest time
Now, based on the schema, we create a model with the following line of code: 
const User = mongoose.model('User',userSchema) --> Mongodb will automatically add s and make 'User' as 'Users'


Creating a route : 
    request is the data that we get from the client side and response is the data that we send back from the server side. 
    We have a server and a client. The interaction between these two is performed by request and the response. 

The best practise is to create separate folder for api routes and the functions. It is the best practice to even put the
logic for handling the routes into a separate function. These logic and functions are called as controllers and 
are placed inside the controller folder. 


Creating an API sign Up route: 
    -Get the information like email and password
    - Hash the password
    -Save inside the database 
        - We create a separate file for the authentication and not place the authentication logic inside the user controller 


By default, we are not allowed to send any json to the server. We need to enable sending body of the request by : 
app.use(express.json())

The saving of the model takes time depending in the network speed. So, to prevent error, we use await. 
By doing this, the exection pauses until that lin of code is fully executed and then only moves to the next line.

For hashing the password
npm install bcryptjs

ERROR HANDLING WITH EXPRESS 
use try and catch statement and if error happens, send status 500. 
The error can be handled by using a middleware function. 
For each error occured in different function of the app, we have to use try and catch block. The part inside the 
try and catch block is almost same and repititive. 
There can sometimes be error which is not in the system but error like password strength is not enough.We need to create 
function that can handle such type of errors. 
Another folder : 
utils> error.js
    function errorHandler --- Takes statusCode and message as input 
    then use javascript constructor to create the error and add statuscode and message to the error and throw error or return error. 
We pass the error to the main error handling function as next(new error("statusCode","message"))
Then, on index.js, there will be main error handler app.use(err,req,res,next) and this function will be the ultimate end of the response cycle to return the response. 


Status codes: 
201 : means that something is created. 